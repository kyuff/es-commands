// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package commands_test

import (
	"context"
	"github.com/kyuff/es"
	"iter"
	"sync"
)

// StoreMock is a mock implementation of commands.Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked commands.Store
//		mockedStore := &StoreMock{
//			OpenFunc: func(ctx context.Context, entityType string, entityID string) es.Stream {
//				panic("mock out the Open method")
//			},
//		}
//
//		// use mockedStore in code that requires commands.Store
//		// and then make assertions.
//
//	}
type StoreMock struct {
	// OpenFunc mocks the Open method.
	OpenFunc func(ctx context.Context, entityType string, entityID string) es.Stream

	// calls tracks calls to the methods.
	calls struct {
		// Open holds details about calls to the Open method.
		Open []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntityType is the entityType argument value.
			EntityType string
			// EntityID is the entityID argument value.
			EntityID string
		}
	}
	lockOpen sync.RWMutex
}

// Open calls OpenFunc.
func (mock *StoreMock) Open(ctx context.Context, entityType string, entityID string) es.Stream {
	if mock.OpenFunc == nil {
		panic("StoreMock.OpenFunc: method is nil but Store.Open was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		EntityType string
		EntityID   string
	}{
		Ctx:        ctx,
		EntityType: entityType,
		EntityID:   entityID,
	}
	mock.lockOpen.Lock()
	mock.calls.Open = append(mock.calls.Open, callInfo)
	mock.lockOpen.Unlock()
	return mock.OpenFunc(ctx, entityType, entityID)
}

// OpenCalls gets all the calls that were made to Open.
// Check the length with:
//
//	len(mockedStore.OpenCalls())
func (mock *StoreMock) OpenCalls() []struct {
	Ctx        context.Context
	EntityType string
	EntityID   string
} {
	var calls []struct {
		Ctx        context.Context
		EntityType string
		EntityID   string
	}
	mock.lockOpen.RLock()
	calls = mock.calls.Open
	mock.lockOpen.RUnlock()
	return calls
}

// StateMock is a mock implementation of commands.State.
//
//	func TestSomethingThatUsesState(t *testing.T) {
//
//		// make and configure a mocked commands.State
//		mockedState := &StateMock{
//			HandleFunc: func(ctx context.Context, event es.Event) error {
//				panic("mock out the Handle method")
//			},
//		}
//
//		// use mockedState in code that requires commands.State
//		// and then make assertions.
//
//	}
type StateMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(ctx context.Context, event es.Event) error

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event es.Event
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *StateMock) Handle(ctx context.Context, event es.Event) error {
	if mock.HandleFunc == nil {
		panic("StateMock.HandleFunc: method is nil but State.Handle was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event es.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	return mock.HandleFunc(ctx, event)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//
//	len(mockedState.HandleCalls())
func (mock *StateMock) HandleCalls() []struct {
	Ctx   context.Context
	Event es.Event
} {
	var calls []struct {
		Ctx   context.Context
		Event es.Event
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// StreamMock is a mock implementation of commands.esStream.
//
//	func TestSomethingThatUsesesStream(t *testing.T) {
//
//		// make and configure a mocked commands.esStream
//		mockedesStream := &StreamMock{
//			AllFunc: func() iter.Seq2[es.Event, error] {
//				panic("mock out the All method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			PositionFunc: func() int64 {
//				panic("mock out the Position method")
//			},
//			ProjectFunc: func(handler es.Handler) error {
//				panic("mock out the Project method")
//			},
//			WriteFunc: func(events ...es.Content) error {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedesStream in code that requires commands.esStream
//		// and then make assertions.
//
//	}
type StreamMock struct {
	// AllFunc mocks the All method.
	AllFunc func() iter.Seq2[es.Event, error]

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// PositionFunc mocks the Position method.
	PositionFunc func() int64

	// ProjectFunc mocks the Project method.
	ProjectFunc func(handler es.Handler) error

	// WriteFunc mocks the Write method.
	WriteFunc func(events ...es.Content) error

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Position holds details about calls to the Position method.
		Position []struct {
		}
		// Project holds details about calls to the Project method.
		Project []struct {
			// Handler is the handler argument value.
			Handler es.Handler
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// Events is the events argument value.
			Events []es.Content
		}
	}
	lockAll      sync.RWMutex
	lockClose    sync.RWMutex
	lockPosition sync.RWMutex
	lockProject  sync.RWMutex
	lockWrite    sync.RWMutex
}

// All calls AllFunc.
func (mock *StreamMock) All() iter.Seq2[es.Event, error] {
	if mock.AllFunc == nil {
		panic("StreamMock.AllFunc: method is nil but esStream.All was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	mock.lockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//
//	len(mockedesStream.AllCalls())
func (mock *StreamMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAll.RLock()
	calls = mock.calls.All
	mock.lockAll.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *StreamMock) Close() error {
	if mock.CloseFunc == nil {
		panic("StreamMock.CloseFunc: method is nil but esStream.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedesStream.CloseCalls())
func (mock *StreamMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Position calls PositionFunc.
func (mock *StreamMock) Position() int64 {
	if mock.PositionFunc == nil {
		panic("StreamMock.PositionFunc: method is nil but esStream.Position was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPosition.Lock()
	mock.calls.Position = append(mock.calls.Position, callInfo)
	mock.lockPosition.Unlock()
	return mock.PositionFunc()
}

// PositionCalls gets all the calls that were made to Position.
// Check the length with:
//
//	len(mockedesStream.PositionCalls())
func (mock *StreamMock) PositionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPosition.RLock()
	calls = mock.calls.Position
	mock.lockPosition.RUnlock()
	return calls
}

// Project calls ProjectFunc.
func (mock *StreamMock) Project(handler es.Handler) error {
	if mock.ProjectFunc == nil {
		panic("StreamMock.ProjectFunc: method is nil but esStream.Project was just called")
	}
	callInfo := struct {
		Handler es.Handler
	}{
		Handler: handler,
	}
	mock.lockProject.Lock()
	mock.calls.Project = append(mock.calls.Project, callInfo)
	mock.lockProject.Unlock()
	return mock.ProjectFunc(handler)
}

// ProjectCalls gets all the calls that were made to Project.
// Check the length with:
//
//	len(mockedesStream.ProjectCalls())
func (mock *StreamMock) ProjectCalls() []struct {
	Handler es.Handler
} {
	var calls []struct {
		Handler es.Handler
	}
	mock.lockProject.RLock()
	calls = mock.calls.Project
	mock.lockProject.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *StreamMock) Write(events ...es.Content) error {
	if mock.WriteFunc == nil {
		panic("StreamMock.WriteFunc: method is nil but esStream.Write was just called")
	}
	callInfo := struct {
		Events []es.Content
	}{
		Events: events,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(events...)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedesStream.WriteCalls())
func (mock *StreamMock) WriteCalls() []struct {
	Events []es.Content
} {
	var calls []struct {
		Events []es.Content
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}

// ContentMock is a mock implementation of commands.esContent.
//
//	func TestSomethingThatUsesesContent(t *testing.T) {
//
//		// make and configure a mocked commands.esContent
//		mockedesContent := &ContentMock{
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedesContent in code that requires commands.esContent
//		// and then make assertions.
//
//	}
type ContentMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *ContentMock) Name() string {
	if mock.NameFunc == nil {
		panic("ContentMock.NameFunc: method is nil but esContent.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedesContent.NameCalls())
func (mock *ContentMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}
